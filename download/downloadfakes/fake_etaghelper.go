// This file was generated by counterfeiter
package downloadfakes

import (
	"sync"

	"github.com/pivotal-cf/spring-cloud-dataflow-for-pcf-cli-plugin/download/cache"
)

type FakeEtagHelper struct {
	GetETagForUrlStub        func(url string, metadataFile string) (string, error)
	getETagForUrlMutex       sync.RWMutex
	getETagForUrlArgsForCall []struct {
		url          string
		metadataFile string
	}
	getETagForUrlReturns struct {
		result1 string
		result2 error
	}
	getETagForUrlReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	SetEtagForUrlStub        func(url string, etag string, cacheEntriesFile string) error
	setEtagForUrlMutex       sync.RWMutex
	setEtagForUrlArgsForCall []struct {
		url              string
		etag             string
		cacheEntriesFile string
	}
	setEtagForUrlReturns struct {
		result1 error
	}
	setEtagForUrlReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeEtagHelper) GetETagForUrl(url string, metadataFile string) (string, error) {
	fake.getETagForUrlMutex.Lock()
	ret, specificReturn := fake.getETagForUrlReturnsOnCall[len(fake.getETagForUrlArgsForCall)]
	fake.getETagForUrlArgsForCall = append(fake.getETagForUrlArgsForCall, struct {
		url          string
		metadataFile string
	}{url, metadataFile})
	fake.recordInvocation("GetETagForUrl", []interface{}{url, metadataFile})
	fake.getETagForUrlMutex.Unlock()
	if fake.GetETagForUrlStub != nil {
		return fake.GetETagForUrlStub(url, metadataFile)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getETagForUrlReturns.result1, fake.getETagForUrlReturns.result2
}

func (fake *FakeEtagHelper) GetETagForUrlCallCount() int {
	fake.getETagForUrlMutex.RLock()
	defer fake.getETagForUrlMutex.RUnlock()
	return len(fake.getETagForUrlArgsForCall)
}

func (fake *FakeEtagHelper) GetETagForUrlArgsForCall(i int) (string, string) {
	fake.getETagForUrlMutex.RLock()
	defer fake.getETagForUrlMutex.RUnlock()
	return fake.getETagForUrlArgsForCall[i].url, fake.getETagForUrlArgsForCall[i].metadataFile
}

func (fake *FakeEtagHelper) GetETagForUrlReturns(result1 string, result2 error) {
	fake.GetETagForUrlStub = nil
	fake.getETagForUrlReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeEtagHelper) GetETagForUrlReturnsOnCall(i int, result1 string, result2 error) {
	fake.GetETagForUrlStub = nil
	if fake.getETagForUrlReturnsOnCall == nil {
		fake.getETagForUrlReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getETagForUrlReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeEtagHelper) SetEtagForUrl(url string, etag string, cacheEntriesFile string) error {
	fake.setEtagForUrlMutex.Lock()
	ret, specificReturn := fake.setEtagForUrlReturnsOnCall[len(fake.setEtagForUrlArgsForCall)]
	fake.setEtagForUrlArgsForCall = append(fake.setEtagForUrlArgsForCall, struct {
		url              string
		etag             string
		cacheEntriesFile string
	}{url, etag, cacheEntriesFile})
	fake.recordInvocation("SetEtagForUrl", []interface{}{url, etag, cacheEntriesFile})
	fake.setEtagForUrlMutex.Unlock()
	if fake.SetEtagForUrlStub != nil {
		return fake.SetEtagForUrlStub(url, etag, cacheEntriesFile)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setEtagForUrlReturns.result1
}

func (fake *FakeEtagHelper) SetEtagForUrlCallCount() int {
	fake.setEtagForUrlMutex.RLock()
	defer fake.setEtagForUrlMutex.RUnlock()
	return len(fake.setEtagForUrlArgsForCall)
}

func (fake *FakeEtagHelper) SetEtagForUrlArgsForCall(i int) (string, string, string) {
	fake.setEtagForUrlMutex.RLock()
	defer fake.setEtagForUrlMutex.RUnlock()
	return fake.setEtagForUrlArgsForCall[i].url, fake.setEtagForUrlArgsForCall[i].etag, fake.setEtagForUrlArgsForCall[i].cacheEntriesFile
}

func (fake *FakeEtagHelper) SetEtagForUrlReturns(result1 error) {
	fake.SetEtagForUrlStub = nil
	fake.setEtagForUrlReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeEtagHelper) SetEtagForUrlReturnsOnCall(i int, result1 error) {
	fake.SetEtagForUrlStub = nil
	if fake.setEtagForUrlReturnsOnCall == nil {
		fake.setEtagForUrlReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setEtagForUrlReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeEtagHelper) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getETagForUrlMutex.RLock()
	defer fake.getETagForUrlMutex.RUnlock()
	fake.setEtagForUrlMutex.RLock()
	defer fake.setEtagForUrlMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeEtagHelper) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ cache.EtagHelper = new(FakeEtagHelper)
