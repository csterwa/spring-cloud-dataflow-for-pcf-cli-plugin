// Code generated by counterfeiter. DO NOT EDIT.
package downloadfakes

import (
	"io"
	"sync"

	"github.com/pivotal-cf/spring-cloud-dataflow-for-pcf-cli-plugin/download"
)

type FakeHttpResponse struct {
	GetHeaderStub        func(name string) string
	getHeaderMutex       sync.RWMutex
	getHeaderArgsForCall []struct {
		name string
	}
	getHeaderReturns struct {
		result1 string
	}
	getHeaderReturnsOnCall map[int]struct {
		result1 string
	}
	GetStatusCodeStub        func() int
	getStatusCodeMutex       sync.RWMutex
	getStatusCodeArgsForCall []struct{}
	getStatusCodeReturns     struct {
		result1 int
	}
	getStatusCodeReturnsOnCall map[int]struct {
		result1 int
	}
	GetBodyStub        func() io.ReadCloser
	getBodyMutex       sync.RWMutex
	getBodyArgsForCall []struct{}
	getBodyReturns     struct {
		result1 io.ReadCloser
	}
	getBodyReturnsOnCall map[int]struct {
		result1 io.ReadCloser
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeHttpResponse) GetHeader(name string) string {
	fake.getHeaderMutex.Lock()
	ret, specificReturn := fake.getHeaderReturnsOnCall[len(fake.getHeaderArgsForCall)]
	fake.getHeaderArgsForCall = append(fake.getHeaderArgsForCall, struct {
		name string
	}{name})
	fake.recordInvocation("GetHeader", []interface{}{name})
	fake.getHeaderMutex.Unlock()
	if fake.GetHeaderStub != nil {
		return fake.GetHeaderStub(name)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getHeaderReturns.result1
}

func (fake *FakeHttpResponse) GetHeaderCallCount() int {
	fake.getHeaderMutex.RLock()
	defer fake.getHeaderMutex.RUnlock()
	return len(fake.getHeaderArgsForCall)
}

func (fake *FakeHttpResponse) GetHeaderArgsForCall(i int) string {
	fake.getHeaderMutex.RLock()
	defer fake.getHeaderMutex.RUnlock()
	return fake.getHeaderArgsForCall[i].name
}

func (fake *FakeHttpResponse) GetHeaderReturns(result1 string) {
	fake.GetHeaderStub = nil
	fake.getHeaderReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeHttpResponse) GetHeaderReturnsOnCall(i int, result1 string) {
	fake.GetHeaderStub = nil
	if fake.getHeaderReturnsOnCall == nil {
		fake.getHeaderReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getHeaderReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeHttpResponse) GetStatusCode() int {
	fake.getStatusCodeMutex.Lock()
	ret, specificReturn := fake.getStatusCodeReturnsOnCall[len(fake.getStatusCodeArgsForCall)]
	fake.getStatusCodeArgsForCall = append(fake.getStatusCodeArgsForCall, struct{}{})
	fake.recordInvocation("GetStatusCode", []interface{}{})
	fake.getStatusCodeMutex.Unlock()
	if fake.GetStatusCodeStub != nil {
		return fake.GetStatusCodeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getStatusCodeReturns.result1
}

func (fake *FakeHttpResponse) GetStatusCodeCallCount() int {
	fake.getStatusCodeMutex.RLock()
	defer fake.getStatusCodeMutex.RUnlock()
	return len(fake.getStatusCodeArgsForCall)
}

func (fake *FakeHttpResponse) GetStatusCodeReturns(result1 int) {
	fake.GetStatusCodeStub = nil
	fake.getStatusCodeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeHttpResponse) GetStatusCodeReturnsOnCall(i int, result1 int) {
	fake.GetStatusCodeStub = nil
	if fake.getStatusCodeReturnsOnCall == nil {
		fake.getStatusCodeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getStatusCodeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeHttpResponse) GetBody() io.ReadCloser {
	fake.getBodyMutex.Lock()
	ret, specificReturn := fake.getBodyReturnsOnCall[len(fake.getBodyArgsForCall)]
	fake.getBodyArgsForCall = append(fake.getBodyArgsForCall, struct{}{})
	fake.recordInvocation("GetBody", []interface{}{})
	fake.getBodyMutex.Unlock()
	if fake.GetBodyStub != nil {
		return fake.GetBodyStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getBodyReturns.result1
}

func (fake *FakeHttpResponse) GetBodyCallCount() int {
	fake.getBodyMutex.RLock()
	defer fake.getBodyMutex.RUnlock()
	return len(fake.getBodyArgsForCall)
}

func (fake *FakeHttpResponse) GetBodyReturns(result1 io.ReadCloser) {
	fake.GetBodyStub = nil
	fake.getBodyReturns = struct {
		result1 io.ReadCloser
	}{result1}
}

func (fake *FakeHttpResponse) GetBodyReturnsOnCall(i int, result1 io.ReadCloser) {
	fake.GetBodyStub = nil
	if fake.getBodyReturnsOnCall == nil {
		fake.getBodyReturnsOnCall = make(map[int]struct {
			result1 io.ReadCloser
		})
	}
	fake.getBodyReturnsOnCall[i] = struct {
		result1 io.ReadCloser
	}{result1}
}

func (fake *FakeHttpResponse) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getHeaderMutex.RLock()
	defer fake.getHeaderMutex.RUnlock()
	fake.getStatusCodeMutex.RLock()
	defer fake.getStatusCodeMutex.RUnlock()
	fake.getBodyMutex.RLock()
	defer fake.getBodyMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeHttpResponse) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ download.HttpResponse = new(FakeHttpResponse)
